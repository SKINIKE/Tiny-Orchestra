import { compileSong } from './song.js';
import type { SongJson } from './types.js';
import { clamp, ensureArrayBuffer, stepToTicks } from './utils.js';

function writeVariableLength(value: number, target: number[]): void {
  let buffer = value & 0x7f;
  while ((value >>= 7)) {
    buffer <<= 8;
    buffer |= (value & 0x7f) | 0x80;
  }
  while (true) {
    target.push(buffer & 0xff);
    if (buffer & 0x80) {
      buffer >>= 8;
    } else {
      break;
    }
  }
}

function textEvent(delta: number, type: number, text: string): number[] {
  const bytes: number[] = [];
  writeVariableLength(delta, bytes);
  const safeText = text.slice(0, 127);
  bytes.push(0xff, type, safeText.length);
  for (let i = 0; i < safeText.length; i += 1) {
    bytes.push(safeText.charCodeAt(i) & 0xff);
  }
  return bytes;
}

function tempoEvent(microsecondsPerQuarter: number): number[] {
  const bytes: number[] = [];
  writeVariableLength(0, bytes);
  bytes.push(0xff, 0x51, 0x03);
  bytes.push((microsecondsPerQuarter >> 16) & 0xff);
  bytes.push((microsecondsPerQuarter >> 8) & 0xff);
  bytes.push(microsecondsPerQuarter & 0xff);
  return bytes;
}

function endOfTrackEvent(delta = 0): number[] {
  const bytes: number[] = [];
  writeVariableLength(delta, bytes);
  bytes.push(0xff, 0x2f, 0x00);
  return bytes;
}

interface MidiNoteEvent {
  tick: number;
  type: 'on' | 'off';
  note: number;
  velocity: number;
}

function assignChannels(song: SongJson): Map<string, number> {
  const channelMap = new Map<string, number>();
  let nextChannel = 0;
  for (const track of song.tracks) {
    const instrument = song.instruments[track.instrument];
    if (!instrument) {
      continue;
    }

    let channel: number;
    if (instrument.type === 'noise' || /dr/i.test(track.id)) {
      channel = 9;
    } else {
      while (nextChannel === 9) {
        nextChannel += 1;
      }
      channel = nextChannel % 16;
      nextChannel += 1;
    }

    channelMap.set(track.id, channel);
  }
  return channelMap;
}

function buildTrackChunk(events: MidiNoteEvent[], trackName: string, channel: number): Uint8Array {
  const bytes: number[] = [];
  bytes.push(...textEvent(0, 0x03, trackName.slice(0, 28)));

  let lastTick = 0;
  for (const event of events) {
    const delta = event.tick - lastTick;
    writeVariableLength(delta, bytes);
    lastTick = event.tick;
    if (event.type === 'on') {
      bytes.push(0x90 | (channel & 0x0f));
      bytes.push(clamp(Math.round(event.note), 0, 127));
      bytes.push(clamp(Math.round(event.velocity), 0, 127));
    } else {
      bytes.push(0x80 | (channel & 0x0f));
      bytes.push(clamp(Math.round(event.note), 0, 127));
      bytes.push(0);
    }
  }

  bytes.push(...endOfTrackEvent());
  const chunk = new Uint8Array(8 + bytes.length);
  const view = new DataView(chunk.buffer);
  chunk[0] = 0x4d;
  chunk[1] = 0x54;
  chunk[2] = 0x72;
  chunk[3] = 0x6b;
  view.setUint32(4, bytes.length, false);
  chunk.set(bytes, 8);
  return chunk;
}

export function encodeMidi(song: SongJson): Uint8Array {
  const compiled = compileSong(song);
  const channelMap = assignChannels(song);
  const tracks = new Map<string, MidiNoteEvent[]>();

  for (const track of song.tracks) {
    tracks.set(track.id, []);
  }

  for (const event of compiled.events) {
    const events = tracks.get(event.track.id);
    if (!events) {
      continue;
    }
    const startTick = stepToTicks(event.startStep, song.tpq);
    const durationTick = Math.max(1, stepToTicks(event.durationSteps, song.tpq));
    events.push({
      tick: startTick,
      type: 'on',
      note: event.note,
      velocity: clamp(event.velocity, 0, 127),
    });
    events.push({
      tick: startTick + durationTick,
      type: 'off',
      note: event.note,
      velocity: 0,
    });
  }

  const tempoTrackBytes: number[] = [];
  const tempo = Math.round(60_000_000 / song.bpm);
  tempoTrackBytes.push(...tempoEvent(tempo));
  tempoTrackBytes.push(...textEvent(0, 0x01, 'Generated by Tiny Orchestra'));
  tempoTrackBytes.push(...endOfTrackEvent());

  const tempoTrack = new Uint8Array(8 + tempoTrackBytes.length);
  const tempoView = new DataView(tempoTrack.buffer);
  tempoTrack.set([0x4d, 0x54, 0x72, 0x6b], 0);
  tempoView.setUint32(4, tempoTrackBytes.length, false);
  tempoTrack.set(tempoTrackBytes, 8);

  const trackChunks: Uint8Array[] = [];
  for (const [trackId, events] of tracks.entries()) {
    const channel = channelMap.get(trackId) ?? 0;
    const sorted = events.sort((a, b) => {
      if (a.tick === b.tick) {
        if (a.type === b.type) {
          return a.note - b.note;
        }
        return a.type === 'off' ? -1 : 1;
      }
      return a.tick - b.tick;
    });
    trackChunks.push(buildTrackChunk(sorted, trackId, channel));
  }

  const header = new Uint8Array(14);
  const headerView = new DataView(header.buffer);
  header.set([0x4d, 0x54, 0x68, 0x64], 0);
  headerView.setUint32(4, 6, false);
  headerView.setUint16(8, 1, false);
  headerView.setUint16(10, trackChunks.length + 1, false);
  headerView.setUint16(12, clamp(Math.round(song.tpq), 1, 9600), false);

  let totalLength = header.length + tempoTrack.length;
  for (const chunk of trackChunks) {
    totalLength += chunk.length;
  }

  const result = new Uint8Array(totalLength);
  let offset = 0;
  result.set(header, offset);
  offset += header.length;
  result.set(tempoTrack, offset);
  offset += tempoTrack.length;
  for (const chunk of trackChunks) {
    result.set(chunk, offset);
    offset += chunk.length;
  }

  return ensureArrayBuffer(result.buffer);
}
